<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一款好看的字体Zed Mono</title>
      <link href="/powehi.github.io/2022/08/24/setzedfont/"/>
      <url>/powehi.github.io/2022/08/24/setzedfont/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>听说最近Atom团队在Alpha测试一款新的编辑器<ahref="https://zed.dev">Zed</a>，使用Rust编写，由GPU来渲染用户界面，支持多人实时协同，目前已经支持包括C/C++、Python、GO、JavaScripy、Markdown、Rust等11种语言，而他们的字体Zed-Mono在我看来具有一种更加舒适的设计，在他人分享的图片上看起来感觉比vscode的原生字体更加生动，因此我在这里分享一下我安装这款字体的经历。</p><p>这款字体目前可以在GitHub上找到，项目地址为https://github.com/zed-industries/zed-fonts.git。</p><span id="more"></span><h2 id="安装">安装</h2><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><thstyle="text-align: left;">老tip：我已经把build好的ttf文件分享到阿里云盘了，地址：https://www.aliyundrive.com/s/voRPDrZYBgj</th></tr></thead><tbody></tbody></table><p>我们可以先通过<code>git</code>将项目<code>clone</code>到本地：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> zedf &amp;&amp; <span class="built_in">cd</span> zedf   <span class="comment">#寻找一个存放项目文件的地方</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zed-industries/zed-fonts.git</span><br><span class="line"><span class="built_in">cd</span> zed-fonts</span><br></pre></td></tr></table></figure></p><p>根据<code>README.md</code>文件中的描述，需要我们运行<code>npm install</code>来安装节点模块，所以需要可以运行<code>npm</code>：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#在MacOS系统中，可以使用Homebrew包管理工具来安装npm</span></span><br><span class="line">brew search node    <span class="comment">#npm在Node v0.6.x版本后已经内建于Node系统</span></span><br><span class="line"><span class="comment">#在Ubuntu系统中，可以使用apt包管理工具来安装npm</span></span><br><span class="line">apt install nodejs npm</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装完成后，可以通过下面指令查看是否安装成功</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure> 运行结果： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">14:32@ ~ % npm -v</span><br><span class="line">8.15.0</span><br><span class="line">14:32@ ~ % </span><br></pre></td></tr></table></figure> 之后按照文档中的描述：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">npm install <span class="comment">#运行结束后会生成一个node_modules文件</span></span><br><span class="line">npm run build -- contents::zed-mono</span><br><span class="line"><span class="comment">#结果会保存在zed-fonts/dist中</span></span><br><span class="line"><span class="comment">#14:35@ dist % ls</span></span><br><span class="line"><span class="comment">#zed-mono</span></span><br><span class="line"><span class="comment">#14:36@ dist % ls zed-mono </span></span><br><span class="line"><span class="comment">#ttfttf-unhintedwoff2zed-mono.css</span></span><br></pre></td></tr></table></figure></p><p>有时候中间会报一些错误，需要结合实际情况进行修正，例如当我在刚开始安装时，报告错误：找不到<code>External dependency &lt;ttfautohint&gt;</code>。于是我在网上找到<code>ttfautohint</code>文件并下载到本地，并在<code>terminal</code>中运行：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/ttfautohint的绝对路径</span><br></pre></td></tr></table></figure> 然后重新运行 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run build -- contents::zed-mono</span><br></pre></td></tr></table></figure>期间可能CPU和ARM的占用会比较高，耗时会比较长，这并不是卡住，只需要多等待一些时间就可以了。</p><h2 id="设置">设置</h2><p>之后进入<code>/dist/zed-mono/ttf</code>，这里会包含很多<code>ttf</code>字体文件，将它们全选后打开：</p><p><img src="../../../../images/zedttf.png" /></p><p>选择安装字体，系统字体册中就可以找到<code>Zed Mono</code>字体：</p><p><img src="../../../../images/zedmono.png" /></p><p>之后打开VsCode，进入设置搜索<code>font</code>，在<code>Font Family</code>处修改为<code>Zed Mono</code>后就会自动加载新字体。</p><h2 id="效果">效果</h2><p>实际效果如下：</p><p><img src="../../../../images/zedshow.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 工具美化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何入门一门小语种之日语</title>
      <link href="/powehi.github.io/2022/08/23/japanese/"/>
      <url>/powehi.github.io/2022/08/23/japanese/</url>
      
        <content type="html"><![CDATA[<h2 id="待补充......">待补充......</h2>]]></content>
      
      
      <categories>
          
          <category> 小语种 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 小语种 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贸易如何使我们生活变得更好</title>
      <link href="/powehi.github.io/2022/08/23/economics2/"/>
      <url>/powehi.github.io/2022/08/23/economics2/</url>
      
        <content type="html"><![CDATA[<h2 id="引言先说一个例子">引言，先说一个例子</h2><p>在一个地区，生活这两个人，分别叫做<spanclass="math inline">\(Frank\)</span>和<spanclass="math inline">\(Ruby\)</span>，这两个人都会生产牛肉和土豆，他们的生产情况如下表所示：</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;">生产1盎司所需要的时间(分钟)</th><th style="text-align: center;">8个小时的产量(盎司)</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Name</td><td style="text-align: center;">牛肉 ｜ 土豆</td><td style="text-align: center;">牛肉 ｜ 土豆</td></tr><tr class="even"><td style="text-align: center;">Frank</td><td style="text-align: center;">60 ｜ 15</td><td style="text-align: center;">08 ｜ 32</td></tr><tr class="odd"><td style="text-align: center;">Ruby</td><td style="text-align: center;">20 ｜ 10</td><td style="text-align: center;">24 ｜ 48</td></tr></tbody></table><span id="more"></span><blockquote><p>他们每个人都面临权衡取舍，当增加牛肉产量时，就会占用本用来生产土豆的时间，使土豆的产量减少，当增加土豆产量时也同样会减少牛肉的产量。</p></blockquote><blockquote><p>些减少的产量被称为<code>机会成本</code>，在经济学十大原理中提到，我们时刻面临着权衡取舍，并且某件东西的成本是为了得到它所放弃的东西。</p></blockquote><p>某一天，<span class="math inline">\(Ruby\)</span>告诉<spanclass="math inline">\(Frank\)</span>，说<spanclass="math inline">\(Frank\)</span>应该完全停止生产牛肉，而把所有时间投入到土豆生产，这样他每天<spanclass="math inline">\(8\)</span>小时可以生产<spanclass="math inline">\(32\)</span>盎司土豆，如果他把<spanclass="math inline">\(32\)</span>盎司重的<spanclass="math inline">\(15\)</span>盎司给<spanclass="math inline">\(Ruby\)</span>，将会得到<spanclass="math inline">\(5\)</span>盎司牛肉的回报，最终<spanclass="math inline">\(Frank\)</span>会得到<spanclass="math inline">\(17\)</span>盎司土豆和<spanclass="math inline">\(5\)</span>盎司牛肉，而不是现在的<spanclass="math inline">\(16\)</span>盎司土豆和<spanclass="math inline">\(4\)</span>盎司牛肉。</p><p>同样，<span class="math inline">\(Ruby\)</span>可以每天用<spanclass="math inline">\(6\)</span>小时生产牛肉，<spanclass="math inline">\(2\)</span>小时生产土豆，那么他将得到<spanclass="math inline">\(18\)</span>盎司牛肉和<spanclass="math inline">\(12\)</span>盎司土豆，用<spanclass="math inline">\(5\)</span>盎司交换来<spanclass="math inline">\(15\)</span>盎司土豆，那最终可以得到<spanclass="math inline">\(13\)</span>盎司牛肉和<spanclass="math inline">\(27\)</span>盎司土豆。</p><p>他们都得到了比过去更多的食物。</p><h2 id="专业化的动力">专业化的动力</h2><h3 id="绝对优势">绝对优势</h3><p><em>一个生产者用比另一个生产者更少的投入生产某种物品的能力。</em></p><p>上例中，由于<spanclass="math inline">\(Ruby\)</span>生产每一种食物所需要的时间(成本)都低于<spanclass="math inline">\(Frank\)</span>，所以说<spanclass="math inline">\(Ruby\)</span>相对<spanclass="math inline">\(Frank\)</span>拥有绝对优势。</p><h3 id="比较优势">比较优势</h3><p><em>一个生产者以低于另一个生产者的机会成本生产某种物品的能力</em></p><p>上例中，当<span class="math inline">\(Ruby\)</span>把<spanclass="math inline">\(10\)</span>分钟用于生产<spanclass="math inline">\(1\)</span>盎司土豆时，将不再可以用<spanclass="math inline">\(10\)</span>分钟生产<spanclass="math inline">\(1/2\)</span>盎司的牛肉，这样<spanclass="math inline">\(1\)</span>盎司土豆的机会成本是<spanclass="math inline">\(1/2\)</span>盎司牛肉。</p><p>同样的计算方法得到对<spanclass="math inline">\(Frank\)</span>来说，<spanclass="math inline">\(1\)</span>盎司土豆的机会成本是<spanclass="math inline">\(1/4\)</span>盎司牛肉。</p><table><thead><tr class="header"><th style="text-align: center;"></th><th style="text-align: center;"><spanclass="math inline">\(1\)</span>盎司牛肉的机会成本</th><th style="text-align: center;"><spanclass="math inline">\(1\)</span>盎司土豆的机会成本</th></tr></thead><tbody><tr class="odd"><td style="text-align: center;">Frank</td><td style="text-align: center;">4盎司土豆</td><td style="text-align: center;">1/4盎司牛肉</td></tr><tr class="even"><td style="text-align: center;">Ruby</td><td style="text-align: center;">2盎司土豆</td><td style="text-align: center;">1/2盎司牛肉</td></tr></tbody></table><p>当一个生产者在生产<spanclass="math inline">\(X\)</span>物品时放弃了较少的其他物品，即生产<spanclass="math inline">\(X\)</span>的机会成本较小，我们就可以说他在该物品的生产上具有比较优势</p><h3 id="比较优势与贸易">比较优势与贸易</h3><p>在以上例子中，<spanclass="math inline">\(Frank\)</span>用更多时间生产土豆，<spanclass="math inline">\(Ruby\)</span>用更多时间生产牛肉，结果土豆的总产量从<spanclass="math inline">\(40\)</span>盎司增加到<spanclass="math inline">\(44\)</span>盎司，牛肉的总产量从<spanclass="math inline">\(16\)</span>盎司增加到<spanclass="math inline">\(18\)</span>盎司，<spanclass="math inline">\(Frank\)</span>和<spanclass="math inline">\(Ruby\)</span>分享这种产量增加的好处。</p><p>对<span class="math inline">\(Frank\)</span>来说，他用<spanclass="math inline">\(15\)</span>盎司土豆换取了<spanclass="math inline">\(5\)</span>盎司牛肉，每<spanclass="math inline">\(1\)</span>盎司牛肉的价格为<spanclass="math inline">\(3\)</span>盎司土豆，而如果他自己生产牛肉，每生产<spanclass="math inline">\(1\)</span>盎司牛肉就意味着放弃可以生产<spanclass="math inline">\(4\)</span>盎司土豆的时间，既每<spanclass="math inline">\(1\)</span>盎司牛肉的价格为<spanclass="math inline">\(4\)</span>盎司土豆。因此<spanclass="math inline">\(Frank\)</span>在交易中以对自己有利的价格买到了牛肉。</p><p>对<span class="math inline">\(Ruby\)</span>来说，他用<spanclass="math inline">\(5\)</span>盎司牛肉换取了<spanclass="math inline">\(15\)</span>盎司土豆，意味着<spanclass="math inline">\(1\)</span>盎司土豆的价格为<spanclass="math inline">\(1/3\)</span>盎司牛肉，而如果他自己生产土豆，每生产<spanclass="math inline">\(1\)</span>盎司土豆就意味着放弃可以生产<spanclass="math inline">\(1/2\)</span>盎司的牛肉，既每<spanclass="math inline">\(1\)</span>盎司土豆的价格为<spanclass="math inline">\(1/2\)</span>盎司牛肉。因此<spanclass="math inline">\(Ruby\)</span>也在交易中以对自己有利的价格买到了土豆。</p><p><strong>一般对在贸易中获益的双方而言，他们进行贸易的价格在两种机会成本之间。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 读书记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>像经济学家一样思考</title>
      <link href="/powehi.github.io/2022/08/23/economics1/"/>
      <url>/powehi.github.io/2022/08/23/economics1/</url>
      
        <content type="html"><![CDATA[<h2 id="像经济学家一样思考">像经济学家一样思考</h2><p>就像计算机领域的算法工程和软件工程，算法工程师经常会考虑实现一种个方面更优秀的算法，或是在时间上或是在空间上；而软件工程师会利用现实中已经存在的算法，做一些实际上的运用，例如制作一款供人们日常使用的软件。</p><p>经济学家们也分为作为科学家的经济学家，和作为政策顾问的经济学家。为了说明白这两种经济学家的区别，我们需要引入两个专业词汇，<code>实证分析</code>和<code>规范分析</code>。</p><p><strong>实证表述</strong>：实证表述是描述性的，它描述世界中客观运行的事情，这件事情不受个人情感而改变。</p><p><strong>规范表述</strong>：规范表述是规定性的，它试图描述世界应该如何运行，一般不同的经济学家由于价值取向和对事物的科学判断不同，会产生不同的规范表述。</p><span id="more"></span><hr /><p><strong>举个例子：</strong></p><p>Portia说：最低工资法引起了失业。</p><p>Noah说：政府应该提高最低工资。</p><p>其中Portia的表述就是实证表述，描述了这个世界是什么样子，而Noah的表述是规范表述，描述了这个世界<em>应该</em>是什么样子。</p><hr /><h3 id="作为科学家的经济学家">作为科学家的经济学家</h3><p>作为科学家的经济学家努力以科学家的客观性来探讨他们的主题。而它们研究经济学的方法与我们研究物理、生物的方法很大程度上是相通的：提出理论，收集数据，分析数据，证明理论。</p><p><strong>一个科学的本质，是冷静的建立与分析关于世界如何运行理论的科学方法。</strong></p><h4 id="科学方法">科学方法</h4><p>当我们提出一项理论之前，我们需要先假设，再通过现实或实验中的数据来进行验证这项理论。在物理学研究中，当伽利略提出动能守恒定律前，他会在实验室中一遍遍重复在斜坡上滚下小球；当牛顿提出万有引力定律前，他也会在实验室中一遍遍两个物体之间的相互作用。但是当一个经济学家想要提出一项理论前，他无法在实验室中模拟验证这项理论，<strong>经济学是一个现实中的科学</strong>，它只可以使用世界向它已经提供的数据来进行研究，因此经济学家们十分关注历史所以提供的自然实验。</p><p>历史上的事件之所以具有研究价值，是因为它不仅使我们了解过去的经济，还能给予我们一种评价当前经济理论的视角。</p><h4 id="假设的作用">假设的作用</h4><p>在研究经济学时，由于现实世界纷繁复杂，我们很难以透过如此复杂的现象看到经济规律的本质，所以就如同在物理题中经常看到的字眼--“假设”，在中学时我们为了更容易理解物体的运动，我们常常假设某平面的摩擦力为<spanclass="math inline">\(0\)</span>；当从高空抛下一个物体时，我们也常假设此时的空气阻力为<spanclass="math inline">\(0\)</span>。在经济学中我们也常常这样做，比如假设只存在两件商品以及两个国家，这种假设可以使我们的研究变得容易，并且在这种研究的基础上，可以更容易去理解复杂的现实世界。</p><hr /><p>当我们想研究政府改变流通中的货币量会对长期短期经济产生怎样的影响，我们常假设价格完全固定；当我们想了解对长期经济的影响时，又回假设所有价格都是完全可变的。</p><hr /><h4 id="经济模型">经济模型</h4><p>数学建模时，我们常常将现实中某些属性数字化，用这些抽象的数据建立模型，以便于忽略一些不重要的影响因素，研究这些属性之间的相互影响；教授解剖学时，我们也常使用一些人体模型，这些模型包括人体的主要器官--心脏、肝脏、肾脏等，从而在学习解剖时不需要关注复杂的肌肉和毛细血管。</p><p>经济学家的模型通常由图形和数字组成，这些模型使我们关注真正重要的东西。</p><ul><li>循环流量图：一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型。</li><li><spanclass="math inline">\(*\)</span>生产可能性边界：表示在可能得到的生产要素与生产技术既定时。一个经济所能生产的产品数量的各种组合的图形。</li><li>关键词：有效率的、无效率的、机会成本</li></ul><h3 id="作为政策顾问的经济学家">作为政策顾问的经济学家</h3><blockquote><p>经济学家和政治哲学家的思想、无论正确与否，实际上都要比一般所想象的更有力量。事实上，这个世界就是由它们统治的。那些自认为能够免受经济学家思想影响的实干家往往也只是某些已故经济学家的俘虏。那些当权狂人信奉的其实也不过是若干年前某些末流学者的狂妄思想。</p><p>-- John Maynard Keynes</p></blockquote><p>但在现实世界中，经济学家的意见由于难以考虑到国家运转的各个方面，所以经济学家的意见并不总是被采纳。</p><p>由于不同经济学家对当前真的的认知存在分歧，比如在消费税和所得税方面，有人认为应该采用消费税，而有些人认为应该采用所得税，并且不同经济学家的价值观不同，比如有人认为穷人和富人应该按收入比例摊付公共支出，也有些人认为穷人和富人应该平分摊付公共支出，导致经济学家之间也经常存在分歧。</p><p>但这种分歧不应该被夸大，在很多时候经济学家对某些事情的主张会达到很高的共识度，比如在是否应该限制租金上限这件事上，大部分经济学家都认为不应该限制租金上限，但市政府还是会不理会经济学家的建议，而对房客收取租金规定上限。</p>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 读书记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode全排列与括号生成</title>
      <link href="/powehi.github.io/2022/08/22/leetcode-220822/"/>
      <url>/powehi.github.io/2022/08/22/leetcode-220822/</url>
      
        <content type="html"><![CDATA[<h2 id="引言">引言</h2><p>对于22题括号生成和46题全排列，它俩的解法殊途同归，都是一种分治+回朔的解法，在已经确定<spanclass="math inline">\(n-1\)</span>个元素后，再来决定第<spanclass="math inline">\(n\)</span>种元素该如何取。</p><p>在第<spanclass="math inline">\(n\)</span>个元素的视角来看，如果有<spanclass="math inline">\(a\)</span>、<spanclass="math inline">\(b\)</span>和<spanclass="math inline">\(c\)</span>三种取法，那么在取任何一种后，计算方法又回到上一段的最后。打个比方，如果确定的是a，那么下次我们可以取<spanclass="math inline">\(b\)</span>或者<spanclass="math inline">\(c\)</span>；如果这次确定的是<spanclass="math inline">\(b\)</span>，那么下次同样我们可以取<spanclass="math inline">\(a\)</span>或者<spanclass="math inline">\(c\)</span>。</p><span id="more"></span><hr /><p>由此引出一个问题，我们如何才能涉及到每一种取法呢？分治递归。</p><p>分治递归这种方法，一般当每一部分数据都包含同样的特征时就可以使用。比如遍历二叉树时，每一个节点都含有一个左孩子和一个右孩子，当遍历到这个节点的某个孩子时，又可以对它的孩子进行与它本身同样的操作，这样我们就可以对每个孩子进行递归。</p><hr /><p>回到问题，当我们确定第<spanclass="math inline">\(n\)</span>个节点时，此时就分出了<spanclass="math inline">\(m\)</span>(方案数)种可能，而这m种方案各自又会分出具有同样特征的<spanclass="math inline">\(m-1\)</span>种方案。</p><p>此时会抛出另一种问题，我们如何才能知道我们已经确定的元素是哪些，以便于我们在下次确定元素时不会和前面已确定的元素重复？</p><h2 id="括号生成">括号生成</h2><p>在括号生成问题中，由于每个括号包括一个左括弧和一个右括弧，因此我们可以用<code>left</code>来记录左括弧数，用<code>right</code>来记录右括弧数。如果我们迭代到某一步，发现可以使用的左括弧和右括弧的数量都已经没有了，那么我们就可以确定我们已经把所有的括弧对都加进字符串，此时直接返回字符串就可以了，否则我们可以选择下一次是添加左括弧还是添加右括弧，以此类推。</p><p><img src="../../../../images/kuohao.png" /></p><p>代码如下: <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">iter</span><span class="params">(vector&lt;string&gt;&amp; ans, <span class="type">int</span> left, <span class="type">int</span> right, string current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; !right) ans.<span class="built_in">push_back</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left) <span class="built_in">iter</span>(ans, left<span class="number">-1</span>, right+<span class="number">1</span>, current+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="built_in">iter</span>(ans, left, right<span class="number">-1</span>, current+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">iter</span>(ans, n, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 在这段代码中，<spanclass="math inline">\(iter\)</span>函数就是递归函数，每次递归到最末尾时我们用完了所有左右括弧，此时将最终字符串添加到向量类型<code>ans</code>中，如果仍然还有左括弧或者右括弧没有添加到字符串，那么我们可以添加左括弧或者右括弧，将这两种选择分而治之，每个人都分化出不同的括弧组合类型。</p><p>需要注意的是，由于我们只有先添加左括弧才能再添加右括弧，所以我们刚开始时右括弧数量为<spanclass="math inline">\(0\)</span>，只有在某个左括弧添加进去后，我们才使右括弧数量加一。</p><h2 id="全排列">全排列</h2><p>在全排列问题中，我们不可以再用n个变量来记录我们的选择，因为此时需要全排列的元素我们无法确定到底有几个，但是根据题目下方的提示，我们发现最多只有<spanclass="math inline">\(6\)</span>个元素进行全排列。 <imgsrc="../../../../images/%E6%8F%90%E7%A4%BA.png" /></p><p>而且因为每种元素只有已选中和未选中两种状态，所以可以用0和1来代表选中的状态，如果我们有<spanclass="math inline">\(6\)</span>个元素，那么只需要一个取值<spanclass="math inline">\(0\)</span>到<spanclass="math inline">\(2^{6}-1\)</span>之间的整数，化为二进制后取值范围将在<spanclass="math inline">\(b\)</span>x<spanclass="math inline">\(000000\)</span>到<spanclass="math inline">\(b\)</span>x<spanclass="math inline">\(111111\)</span>之间，每一位是<spanclass="math inline">\(0\)</span>时代表可以被选中，每一位是<spanclass="math inline">\(1\)</span>时代表已经被选中。</p><p>分治方法也如同括号生成算法，当每找到一个<spanclass="math inline">\(0\)</span>时就可以开启一个分支，从而可以取遍每种情况。算法如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constructor</span><span class="params">(<span class="type">int</span> tags, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans, vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tags == <span class="built_in">pow</span>(<span class="number">2</span>, nums.<span class="built_in">size</span>())<span class="number">-1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tag = tags;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(tag &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nv</span><span class="params">(v)</span></span>;</span><br><span class="line">                nv.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">constructor</span>(tags+<span class="built_in">pow</span>(<span class="number">2</span>,i), ans, nv, nums);</span><br><span class="line">            &#125;</span><br><span class="line">            tag &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">constructor</span>(<span class="number">0</span>, ans, vector&lt;<span class="type">int</span>&gt;&#123;&#125;, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中每个元素会产生<spanclass="math inline">\(n!\)</span>种后缀，又存在<spanclass="math inline">\(n\)</span>个元素，所以时间复杂度为<spanclass="math inline">\(O(n\times{n!})\)</span>。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分治递归 </tag>
            
            <tag> 回朔法 </tag>
            
            <tag> 刷题记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《 THE ROMANOVS 》- 罗曼诺夫王朝</title>
      <link href="/powehi.github.io/2022/08/22/romanovs/"/>
      <url>/powehi.github.io/2022/08/22/romanovs/</url>
      
        <content type="html"><![CDATA[<p><strong>“我们历史上最大的罪人，是那些自己放弃权力的软蛋，尼古拉二世和米哈伊文·戈尔巴乔夫。他们竟允许权利被歇斯底里的狂人和疯子夺走。”</strong>--- 弗拉基米尔·弗拉基米罗维奇·普京</p><span id="more"></span>]]></content>
      
      
      <categories>
          
          <category> 历史学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书记录 </tag>
            
            <tag> 历史学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>统计学习概论</title>
      <link href="/powehi.github.io/2022/08/21/statistic/"/>
      <url>/powehi.github.io/2022/08/21/statistic/</url>
      
        <content type="html"><![CDATA[<h2 id="统计学习的特点">统计学习的特点：</h2><ol type="1"><li>统计学习以计算机及网络为平台，建立在计算机及网络上</li><li>统计学习以数据为研究对象，是数据驱动的学科</li><li>统计学习的目的是对数据进行预测与分析</li><li>统计学习以方法为中心，构建模型并对模型进行预测与分析</li><li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科</li></ol><span id="more"></span><table><tbody><tr class="odd"><td>赫尔伯特<span class="math inline">\(·\)</span>西蒙 (Herbert A.Simon)曾对学习给出以下定义：“如果一个系统能够通过执行某个过程改进它的性能，这就是学习。”</td></tr></tbody></table><h2 id="统计学习的对象数据">统计学习的对象：数据</h2><p>它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，回到对数据的分析和预测中去。</p><p>统计学习中对数据的基本假设：同类数据具有一定的统计规律性，这是统计学习的前提。</p><h2id="统计学习的目的用于对数据的预测和分析特别是对未知数据的预测与分析">统计学习的目的：用于对数据的预测和分析，特别是对未知数据的预测与分析。</h2><h3 id="考虑两点">考虑两点</h3><ol type="1"><li>学习什么样的模型</li><li>如何学习模型</li></ol><h2id="统计学习方法从给定的有限的用于学习的训练数据集和出发假设数据是独立同分布产生的并且要学习的模型属于某个函数的集合假设空间">★统计学习方法：从给定的、有限的、用于学习的训练数据集和出发，假设数据是独立同分布产生的；并且要学习的模型属于某个函数的集合(假设空间)</h2><h3 id="一包括三点三要素">一、包括三点，三要素</h3><ol type="1"><li>模型的假设空间（模型model）</li><li>模型选择的准则（策略strategy）</li><li>模型学习的算法（算法algorithm）</li></ol><table><tbody><tr class="odd"><td>如果最优化问题又显式的解析解，这个最优化问题就比较简单。但通常解析解不存在，就需要用数值计算的方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。</td></tr></tbody></table><h3 id="二损失函数与风险函数">二、损失函数与风险函数**</h3><ol type="1"><li><p><span class="math inline">\(0\)</span>-<spanclass="math inline">\(1\)</span>损失函数（<spanclass="math inline">\(0\)</span>-<span class="math inline">\(1\)</span>loss function）</p><p><span class="math display">\[\displaystyle{L(Y,f(X))=\begin{cases}1&amp; Y\neq f(X) \\ 0 &amp;  Y= f(X)\end{cases}}\]</span></p></li><li><p>平方损失函数（quadratic loss function）</p><p><spanclass="math display">\[\displaystyle{L(Y,f(X))=(Y-f(X))^2}\]</span></p></li><li><p>绝对损失函数（absolute loss function）</p><p><spanclass="math display">\[\displaystyle{L(Y,f(X))=|Y-f(X)|}\]</span></p></li><li><p>对数损失函数（logarithmic loss function）</p><p><span class="math display">\[\displaystyle{L(Y,f(X))=-\logP(Y|X)}\]</span></p></li></ol><ul><li><p>损失函数值越小，模型就越好，下面是损失函数的期望值：</p><p><spanclass="math display">\[\displaystyle{R_{exp}(f)=E_P[L(Y,f(X))]=\int_{\Chi* \Upsilon}L(y,f(x))P(x,y)dxdy}\]</span></p></li><li><p>理论上模型<spanclass="math inline">\(f(X)\)</span>关于联合分布<spanclass="math inline">\(P(X,Y)\)</span>的平均意义下的损失，成为<code>风险函数</code>或<code>期望损失</code>，学习目标就是选择期望风险最小的模型</p></li></ul><h3id="三经验风险最小化与结构风险最小化">三、经验风险最小化与结构风险最小化</h3><p>经验风险是模型关于训练样本集的平均损失，根据大数定理，样本容量<spanclass="math inline">\(N\)</span>趋于无穷大时经验风险<spanclass="math inline">\(R_{emp}(f)\)</span>趋于期望风险<spanclass="math inline">\(R_{exp}(f)\)</span>，但现实是训练样本有限，所以经验风险估计期望常常并不理想，要对经验风险进行一定矫正。</p><p><strong>这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。</strong></p><ol type="1"><li><p>经验风险最小化</p><p>当模型是条件概率分布、损失函数是对数损失函数、经验风险最小化就等价于极大似然估计。</p><p><spanclass="math display">\[\displaystyle{R_{emp}(f)=\cfrac{1}{N}\quad\sum_{i=1}^{N}L(y_i,f(x_i))}\]</span></p></li><li><p>结构风险最小化</p><p>结构分概念最小化等价于正则化（regularizer）。</p><p>结构风险在经验风险上加上表示模型复杂度的正则化（regularizer）或罚项（penaltyterm）。</p><p><spanclass="math display">\[\displaystyle{R_{emp}(f)=\cfrac{1}{N}\quad\sum_{i=1}^{N}L(y_i,f(x_i))+ \lambda J(f)}\]</span></p><p>其中<span class="math inline">\(J(f)\)</span>为模型复杂度，模型<spanclass="math inline">\(f\)</span>越复杂，复杂度<spanclass="math inline">\(J(f)\)</span>就越大；<spanclass="math inline">\(\lambda\geqslant0\)</span>是系数，用以权衡经验风险和模型复杂度。</p></li></ol><h2 id="统计学习的研究">统计学习的研究</h2><ol type="1"><li>统计学习方法的研究旨在开发新的<strong>学习方法</strong></li><li>统计学习理论的研究在于探求统计学习方法的<strong>有效性与效率</strong>，以及统计学习的<strong>基本理论问题</strong></li><li>统计学习应用的研究主要考虑将统计学习方法<strong>应用到实际问题中去</strong>，解决实际问题</li></ol><h2 id="模型评估与模型选择">模型评估与模型选择</h2><p>当损失函数给定时，基于损失函数的训练误差和模型的测试误差就成为学习方法的评估标准。</p><blockquote><p>过拟合问题：如果一味提高测试数据的预测能力，就可能导致过拟合问题。具体体现在学习是选择的模型参数过多，对已知的测试数据预测效果很好，但对于未知数据预测结果很差。</p></blockquote><p><img src="../../../../images/IMG_0584.jpg" /></p><hr /><p>如果在假设空间中存在“真”模型，那么所选模型要与真模型参数个数相同，参数向量与真模型的参数向量相近。</p><blockquote><p>对于测试误差，会随着模型复杂度先减小，达到最小之后又增大</p></blockquote><p><img src="../../../../images/PNG图像.png" /></p><hr /><h2 id="正则化验证与交叉验证">正则化验证与交叉验证</h2><p><code>两种用于选择模型的方法</code></p><ul><li><p>其中<strong>正则化验证</strong>是结构风险最小化策略的实现，正则化符合奥卡姆剃须刀原理：在所有可能选择的模型中，能够很好解释已知数据并且十分简单的才是好模型。</p></li><li><p>另一种常用的是<strong>交叉验证</strong>，对于给定的样本，将其随机切分成三部分，分别是训练集（训练模型）、验证集（选择模型）、测试集（评估模型）。基本思想是重复使用数据，可以应对实际问题中数据不足的问题。</p></li></ul><h3 id="一交叉验证的三种类型">一、交叉验证的三种类型</h3><ol type="1"><li><p>简单交叉验证</p><p>例如在<spanclass="math inline">\(MNIST\)</span>分类问题中将样本随机分成两部分、测试集（<spanclass="math inline">\(30\%\)</span>）与训练集（<spanclass="math inline">\(70\%\)</span>）。</p></li><li><p><span class="math inline">\(S\)</span>折交叉验证</p><p>将数据切分成<spanclass="math inline">\(S\)</span>个互不相交、大小相同的子集，利用<spanclass="math inline">\(S-1\)</span>个子集数据进行训练，用余下的数据测试模型；将这一过程进行<spanclass="math inline">\(S\)</span>次重复选择，最后选出评价误差最小的模型。</p></li><li><p>留一交叉验证</p><p>是<span class="math inline">\(S\)</span>折交叉验证的特殊情形（<spanclass="math inline">\(S=N\)</span>），往往在数据缺乏的情况下使用。</p></li></ol><h2 id="泛化误差">泛化误差</h2><blockquote><p>泛化是指模型对未知数据的预测能力，泛化误差反映了学习方法的泛化能力。事实上，泛化误差就是所学到模型的期望风险。<spanclass="math inline">\(\displaystyle{R_{exp}(\hat{f})=E_P[L(Y,\hat{f}(X))]=\int_{\Chi*\Upsilon}L(y,\hat{f}(x))P(x,y)dxdy}\)</span></p></blockquote><p><code>泛化误差上界，假设空间越大，模型越难学习，泛化误差上界越大</code></p><p>对于<span class="math inline">\(f_N\)</span>的泛化能力，<spanclass="math inline">\(R(f_N)=E[L(Y,f_N(X))]\)</span></p><p><img src="../../../../images/PNG图像_2.png" /></p><hr /><ul><li><span class="math inline">\(Hoefffding\)</span>不等式</li></ul><p><img src="../../../../images/PNG图像_3.png" /></p><p><img src="../../../../images/PNG图像_4.png" /></p><hr /><h2 id="生成模型与判别模型">生成模型与判别模型</h2><p><em>监督学习方法又可以分为生成方法（generativeapproach）与判别方法（discriminativeapproach），所学到的模型分别为生成模型（generativemodel）与判别模型（discriminative model）。</em></p><ol type="1"><li>生成方法由数据学习联合概率密度<spanclass="math inline">\(P(X,Y)\)</span>，然后求出条件概率密度<spanclass="math inline">\(P(Y|X)\)</span>，即生成模型<spanclass="math inline">\(\displaystyle{P(Y|X)=\cfrac{P(X,Y)}{P(X)}}\)</span>。</li></ol><blockquote><p><strong>典型生成模型</strong>：朴素贝叶斯法，隐马尔可夫模型</p><p><strong>特点：可以还原出联合概率密度，收敛速度快，当存在隐变量时仍然可以使用</strong></p></blockquote><ol start="2" type="1"><li>判别方法直接学习决策模型<spanclass="math inline">\(f(X)\)</span>或者条件概率密度<spanclass="math inline">\(P(Y|X)\)</span>，作为预测模型。</li></ol><blockquote><p><strong>典型判别模型</strong>：<spanclass="math inline">\(k\)</span>近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法、条件随机场等</p><p><strong>特点：准确率更高，方便对数据进行各种程度上的抽象，定义特征并使用特征，简化学习问题</strong></p></blockquote><h2 id="监督学习应用">监督学习应用</h2><ol type="1"><li><p>分类问题</p></li><li><p>标注问题（隐马尔可夫模型，条件随机场）</p></li><li><p>回归问题</p><p>用于预测输入变量和输出变量之间的关系，当输入发生变化时，输出值随之发生变化。回归模型正是输入变量到输出变量之间的映射函数，等价于函数拟合。</p></li></ol><ul><li>根据输入变量个数分为一元回归和多元回归；按照所拟合函数类型分为线性回归和非线性回归。</li><li>最常用的是平方损失函数，可以用最小二乘法求解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数学 </category>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书记录 </tag>
            
            <tag> 统计学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>经济学原理</title>
      <link href="/powehi.github.io/2022/08/21/ECONOMICS/"/>
      <url>/powehi.github.io/2022/08/21/ECONOMICS/</url>
      
        <content type="html"><![CDATA[<h1 id="我们为什么要学习经济学">我们为什么要学习经济学？</h1><ol type="1"><li>经济学能够帮助我们理解我们所生活的世界。</li><li>经济学能够使我们更精明地参与经济，而在日常生活中，我们需要做许多经济决策。</li><li>经济学能够使我们更好地理解经济政策的潜力与局限性。</li><li>经济学原理可以运用到生活中的方方面面 <span id="more"></span><code>这一章讲记录经济学的十大原理，并在以后各章中会充分解释这些思想。</code># 经济学十大原理</li></ol><ul><li><h2 id="人们如何做出决策">人们如何做出决策</h2><h3 id="原理一人们面临权衡取舍">原理一：人们面临权衡取舍</h3><h3id="原理二某种东西的成本是为了得到它所放弃的东西">原理二：某种东西的成本是为了得到它所放弃的东西</h3><h3 id="原理三理性人考虑边际量">原理三：理性人考虑边际量</h3><h3id="原理四人们会对激励作出反应">原理四：人们会对激励作出反应</h3></li><li><h2 id="人们如何互相影响">人们如何互相影响</h2><h3id="原理五贸易可以使每个人的状况都变得更好">原理五：贸易可以使每个人的状况都变得更好</h3><h3id="原理六市场通常是组织经济活动的一种好方法">原理六：市场通常是组织经济活动的一种好方法</h3><h3id="原理七政府有时可以改善市场结果">原理七：政府有时可以改善市场结果</h3></li><li><h2 id="整体经济如何运行">整体经济如何运行</h2><h3id="原理八一国的生活水平取决于它生产物品与服务的能力">原理八：一国的生活水平取决于它生产物品与服务的能力</h3><h3id="原理九当政府发行了过多货物时物价上升">原理九：当政府发行了过多货物时，物价上升</h3><h3id="原理十社会面领通货膨胀与失业之间的短期权衡">原理十：社会面领通货膨胀与失业之间的短期权衡</h3></li></ul>]]></content>
      
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
            <tag> 读书记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/powehi.github.io/2022/08/20/hello-world/"/>
      <url>/powehi.github.io/2022/08/20/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
