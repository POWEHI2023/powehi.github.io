<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>像经济学家一样思考</title>
    <url>/powehi.github.io/2022/08/23/economics1/</url>
    <content><![CDATA[<h2 id="像经济学家一样思考">像经济学家一样思考</h2>
<p>就像计算机领域的算法工程和软件工程，算法工程师经常会考虑实现一种个方面更优秀的算法，或是在时间上或是在空间上；而软件工程师会利用现实中已经存在的算法，做一些实际上的运用，例如制作一款供人们日常使用的软件。</p>
<p>经济学家们也分为作为科学家的经济学家，和作为政策顾问的经济学家。为了说明白这两种经济学家的区别，我们需要引入两个专业词汇，<code>实证分析</code>和<code>规范分析</code>。</p>
<p><strong>实证表述</strong>：实证表述是描述性的，它描述世界中客观运行的事情，这件事情不受个人情感而改变。</p>
<p><strong>规范表述</strong>：规范表述是规定性的，它试图描述世界应该如何运行，一般不同的经济学家由于价值取向和对事物的科学判断不同，会产生不同的规范表述。</p>
<span id="more"></span>
<hr />
<p><strong>举个例子：</strong></p>
<p>Portia说：最低工资法引起了失业。</p>
<p>Noah说：政府应该提高最低工资。</p>
<p>其中Portia的表述就是实证表述，描述了这个世界是什么样子，而Noah的表述是规范表述，描述了这个世界<em>应该</em>是什么样子
。</p>
<hr />
<h3 id="作为科学家的经济学家">作为科学家的经济学家</h3>
<p>作为科学家的经济学家努力以科学家的客观性来探讨他们的主题。而它们研究经济学的方法与我们研究物理、生物的方法很大程度上是相通的：提出理论，收集数据，分析数据，证明理论。</p>
<p><strong>一个科学的本质，是冷静的建立与分析关于世界如何运行理论的科学方法。</strong></p>
<h4 id="科学方法">科学方法</h4>
<p>当我们提出一项理论之前，我们需要先假设，再通过现实或实验中的数据来进行验证这项理论。在物理学研究中，当牛顿提出万有引力定律前，他也会在实验室中一遍遍验证两个物体之间的相互作用。但是当一个经济学家想要提出一项理论前，他无法在实验室中模拟验证这项理论，<strong>经济学是一个现实中的科学</strong>，它只可以使用世界向它已经提供的数据来进行研究，因此经济学家们十分关注历史所提供的自然实验。</p>
<p>历史上的事件之所以具有研究价值，是因为它不仅使我们了解过去的经济，还能给予我们一种评价当前经济理论的视角。</p>
<h4 id="假设的作用">假设的作用</h4>
<p>在研究经济学时，由于现实世界纷繁复杂，我们很难以透过如此复杂的现象看到经济规律的本质，所以就如同在物理题中经常看到的字眼--“假设”，在中学时我们为了更容易理解物体的运动，我们常常假设某平面的摩擦力为<span
class="math inline">\(0\)</span>；当从高空抛下一个物体时，我们也常假设此时的空气阻力为<span
class="math inline">\(0\)</span>。在经济学中我们也常常这样做，比如假设只存在两件商品以及两个国家，这种假设可以使我们的研究变得容易，并且在这种研究的基础上，可以更容易去理解复杂的现实世界。</p>
<hr />
<p>当我们想研究政府改变流通中的货币量会对长期短期经济产生怎样的影响，我们常假设价格完全固定；当我们想了解对长期经济的影响时，又会假设所有价格都是完全可变的。</p>
<hr />
<h4 id="经济模型">经济模型</h4>
<p>数学建模时，我们常常将现实中某些属性数字化，用这些抽象的数据建立模型，以便于忽略一些不重要的影响因素，研究这些属性之间的相互影响；教授解剖学时，我们也常使用一些人体模型，这些模型包括人体的主要器官--心脏、肝脏、肾脏等，从而在学习解剖时不需要关注复杂的肌肉和毛细血管。</p>
<p>经济学家的模型通常由图形和数字组成，这些模型使我们关注真正重要的东西。</p>
<ul>
<li>循环流量图：一个说明货币如何通过市场在家庭与企业之间流动的直观经济模型。</li>
<li><span
class="math inline">\(*\)</span>生产可能性边界：表示在可能得到的生产要素与生产技术既定时。一个经济所能生产的产品数量的各种组合的图形。</li>
<li>关键词：有效率的、无效率的、机会成本</li>
</ul>
<h3 id="作为政策顾问的经济学家">作为政策顾问的经济学家</h3>
<blockquote>
<p>经济学家和政治哲学家的思想、无论正确与否，实际上都要比一般所想象的更有力量。事实上，这个世界就是由它们统治的。那些自认为能够免受经济学家思想影响的实干家往往也只是某些已故经济学家的俘虏。那些当权狂人信奉的其实也不过是若干年前某些末流学者的狂妄思想。</p>
<p>-- John Maynard Keynes</p>
</blockquote>
<p>但在现实世界中，经济学家的意见由于难以考虑到国家运转的各个方面，所以经济学家的意见并不总是被采纳。</p>
<p>由于不同经济学家对当前真理的认知存在分歧，比如在消费税和所得税方面，有人认为应该采用消费税，而有些人认为应该采用所得税，并且不同经济学家的价值观不同，比如有人认为穷人和富人应该按收入比例摊付公共支出，也有些人认为穷人和富人应该平分摊付公共支出，导致经济学家之间也经常存在分歧。</p>
<p>但这种分歧不应该被夸大，在很多时候经济学家对某些事情的主张会达到很高的共识度，比如在是否应该限制租金上限这件事上，大部分经济学家都认为不应该限制租金上限，但市政府还是会不理会经济学家的建议，而对房客收取租金规定上限。</p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>经济学</tag>
        <tag>读书记录</tag>
      </tags>
  </entry>
  <entry>
    <title>贸易如何使我们生活变得更好</title>
    <url>/powehi.github.io/2022/08/23/economics2/</url>
    <content><![CDATA[<h2 id="引言先说一个例子">引言，先说一个例子</h2>
<p>在一个地区，生活着两个人，分别叫做<span
class="math inline">\(Frank\)</span>和<span
class="math inline">\(Ruby\)</span>，这两个人都会生产牛肉和土豆，他们的生产情况如下表所示：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;">生产1盎司所需要的时间(分钟)</th>
<th style="text-align: center;">8个小时的产量(盎司)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Name</td>
<td style="text-align: center;">牛肉 ｜ 土豆</td>
<td style="text-align: center;">牛肉 ｜ 土豆</td>
</tr>
<tr class="even">
<td style="text-align: center;">Frank</td>
<td style="text-align: center;">60 ｜ 15</td>
<td style="text-align: center;">08 ｜ 32</td>
</tr>
<tr class="odd">
<td style="text-align: center;">Ruby</td>
<td style="text-align: center;">20 ｜ 10</td>
<td style="text-align: center;">24 ｜ 48</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<blockquote>
<p>他们每个人都面临权衡取舍，当增加牛肉产量时，就会占用本用来生产土豆的时间，使土豆的产量减少，当增加土豆产量时也同样会减少牛肉的产量。</p>
</blockquote>
<blockquote>
<p>些减少的产量被称为<code>机会成本</code>，在经济学十大原理中提到，我们时刻面临着权衡取舍，并且某件东西的成本是为了得到它所放弃的东西。</p>
</blockquote>
<p>某一天，<span class="math inline">\(Ruby\)</span>告诉<span
class="math inline">\(Frank\)</span>，说<span
class="math inline">\(Frank\)</span>应该完全停止生产牛肉，而把所有时间投入到土豆生产，这样他每天<span
class="math inline">\(8\)</span>小时可以生产<span
class="math inline">\(32\)</span>盎司土豆，如果他把<span
class="math inline">\(32\)</span>盎司重的<span
class="math inline">\(15\)</span>盎司给<span
class="math inline">\(Ruby\)</span>，将会得到<span
class="math inline">\(5\)</span>盎司牛肉的回报，最终<span
class="math inline">\(Frank\)</span>会得到<span
class="math inline">\(17\)</span>盎司土豆和<span
class="math inline">\(5\)</span>盎司牛肉，而不是现在的<span
class="math inline">\(16\)</span>盎司土豆和<span
class="math inline">\(4\)</span>盎司牛肉。</p>
<p>同样，<span class="math inline">\(Ruby\)</span>可以每天用<span
class="math inline">\(6\)</span>小时生产牛肉，<span
class="math inline">\(2\)</span>小时生产土豆，那么他将得到<span
class="math inline">\(18\)</span>盎司牛肉和<span
class="math inline">\(12\)</span>盎司土豆，用<span
class="math inline">\(5\)</span>盎司交换来<span
class="math inline">\(15\)</span>盎司土豆，那最终可以得到<span
class="math inline">\(13\)</span>盎司牛肉和<span
class="math inline">\(27\)</span>盎司土豆。</p>
<p>他们都得到了比过去更多的食物。</p>
<h2 id="专业化的动力">专业化的动力</h2>
<h3 id="绝对优势">绝对优势</h3>
<p><em>一个生产者用比另一个生产者更少的投入生产某种物品的能力。</em></p>
<p>上例中，由于<span
class="math inline">\(Ruby\)</span>生产每一种食物所需要的时间(成本)都低于<span
class="math inline">\(Frank\)</span>，所以说<span
class="math inline">\(Ruby\)</span>相对<span
class="math inline">\(Frank\)</span>拥有绝对优势。</p>
<h3 id="比较优势">比较优势</h3>
<p><em>一个生产者以低于另一个生产者的机会成本生产某种物品的能力</em></p>
<p>上例中，当<span class="math inline">\(Ruby\)</span>把<span
class="math inline">\(10\)</span>分钟用于生产<span
class="math inline">\(1\)</span>盎司土豆时，将不再可以用<span
class="math inline">\(10\)</span>分钟生产<span
class="math inline">\(1/2\)</span>盎司的牛肉，这样<span
class="math inline">\(1\)</span>盎司土豆的机会成本是<span
class="math inline">\(1/2\)</span>盎司牛肉。</p>
<p>同样的计算方法得到对<span
class="math inline">\(Frank\)</span>来说，<span
class="math inline">\(1\)</span>盎司土豆的机会成本是<span
class="math inline">\(1/4\)</span>盎司牛肉。</p>
<table>
<thead>
<tr class="header">
<th style="text-align: center;"></th>
<th style="text-align: center;"><span
class="math inline">\(1\)</span>盎司牛肉的机会成本</th>
<th style="text-align: center;"><span
class="math inline">\(1\)</span>盎司土豆的机会成本</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">Frank</td>
<td style="text-align: center;">4盎司土豆</td>
<td style="text-align: center;">1/4盎司牛肉</td>
</tr>
<tr class="even">
<td style="text-align: center;">Ruby</td>
<td style="text-align: center;">2盎司土豆</td>
<td style="text-align: center;">1/2盎司牛肉</td>
</tr>
</tbody>
</table>
<p>当一个生产者在生产<span
class="math inline">\(X\)</span>物品时放弃了较少的其他物品，即生产<span
class="math inline">\(X\)</span>的机会成本较小，我们就可以说他在该物品的生产上具有比较优势</p>
<h3 id="比较优势与贸易">比较优势与贸易</h3>
<p>在以上例子中，<span
class="math inline">\(Frank\)</span>用更多时间生产土豆，<span
class="math inline">\(Ruby\)</span>用更多时间生产牛肉，结果土豆的总产量从<span
class="math inline">\(40\)</span>盎司增加到<span
class="math inline">\(44\)</span>盎司，牛肉的总产量从<span
class="math inline">\(16\)</span>盎司增加到<span
class="math inline">\(18\)</span>盎司，<span
class="math inline">\(Frank\)</span>和<span
class="math inline">\(Ruby\)</span>分享这种产量增加的好处。</p>
<p>对<span class="math inline">\(Frank\)</span>来说，他用<span
class="math inline">\(15\)</span>盎司土豆换取了<span
class="math inline">\(5\)</span>盎司牛肉，每<span
class="math inline">\(1\)</span>盎司牛肉的价格为<span
class="math inline">\(3\)</span>盎司土豆，而如果他自己生产牛肉，每生产<span
class="math inline">\(1\)</span>盎司牛肉就意味着放弃可以生产<span
class="math inline">\(4\)</span>盎司土豆的时间，既每<span
class="math inline">\(1\)</span>盎司牛肉的价格为<span
class="math inline">\(4\)</span>盎司土豆。因此<span
class="math inline">\(Frank\)</span>在交易中以对自己有利的价格买到了牛肉。</p>
<p>对<span class="math inline">\(Ruby\)</span>来说，他用<span
class="math inline">\(5\)</span>盎司牛肉换取了<span
class="math inline">\(15\)</span>盎司土豆，意味着<span
class="math inline">\(1\)</span>盎司土豆的价格为<span
class="math inline">\(1/3\)</span>盎司牛肉，而如果他自己生产土豆，每生产<span
class="math inline">\(1\)</span>盎司土豆就意味着放弃可以生产<span
class="math inline">\(1/2\)</span>盎司的牛肉，既每<span
class="math inline">\(1\)</span>盎司土豆的价格为<span
class="math inline">\(1/2\)</span>盎司牛肉。因此<span
class="math inline">\(Ruby\)</span>也在交易中以对自己有利的价格买到了土豆。</p>
<p><strong>一般对在贸易中获益的双方而言，他们进行贸易的价格在两种机会成本之间。</strong></p>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>经济学</tag>
        <tag>读书记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/powehi.github.io/2022/08/20/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very
first post. Check <a href="https://hexo.io/docs/">documentation</a> for
more info. If you get any problems when using Hexo, you can find the
answer in <a
href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or
you can ask me on <a
href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<span id="more"></span>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a
href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>经济学原理</title>
    <url>/powehi.github.io/2022/08/21/ECONOMICS/</url>
    <content><![CDATA[<h1 id="我们为什么要学习经济学">我们为什么要学习经济学？</h1>
<ol type="1">
<li>经济学能够帮助我们理解我们所生活的世界。</li>
<li>经济学能够使我们更精明地参与经济，而在日常生活中，我们需要做许多经济决策。</li>
<li>经济学能够使我们更好地理解经济政策的潜力与局限性。</li>
<li>经济学原理可以运用到生活中的方方面面 <span id="more"></span>
<code>这一章讲记录经济学的十大原理，并在以后各章中会充分解释这些思想。</code>
# 经济学十大原理</li>
</ol>
<ul>
<li><h2 id="人们如何做出决策">人们如何做出决策</h2>
<h3 id="原理一人们面临权衡取舍">原理一：人们面临权衡取舍</h3>
<h3
id="原理二某种东西的成本是为了得到它所放弃的东西">原理二：某种东西的成本是为了得到它所放弃的东西</h3>
<h3 id="原理三理性人考虑边际量">原理三：理性人考虑边际量</h3>
<h3
id="原理四人们会对激励作出反应">原理四：人们会对激励作出反应</h3></li>
<li><h2 id="人们如何互相影响">人们如何互相影响</h2>
<h3
id="原理五贸易可以使每个人的状况都变得更好">原理五：贸易可以使每个人的状况都变得更好</h3>
<h3
id="原理六市场通常是组织经济活动的一种好方法">原理六：市场通常是组织经济活动的一种好方法</h3>
<h3
id="原理七政府有时可以改善市场结果">原理七：政府有时可以改善市场结果</h3></li>
<li><h2 id="整体经济如何运行">整体经济如何运行</h2>
<h3
id="原理八一国的生活水平取决于它生产物品与服务的能力">原理八：一国的生活水平取决于它生产物品与服务的能力</h3>
<h3
id="原理九当政府发行了过多货物时物价上升">原理九：当政府发行了过多货物时，物价上升</h3>
<h3
id="原理十社会面领通货膨胀与失业之间的短期权衡">原理十：社会面领通货膨胀与失业之间的短期权衡</h3></li>
</ul>
]]></content>
      <categories>
        <category>经济学</category>
      </categories>
      <tags>
        <tag>经济学</tag>
        <tag>读书记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Leetcode全排列与括号生成</title>
    <url>/powehi.github.io/2022/08/22/leetcode-220822/</url>
    <content><![CDATA[<h2 id="引言">引言</h2>
<p>对于22题括号生成和46题全排列，它俩的解法殊途同归，都是一种分治+回朔的解法，在已经确定<span
class="math inline">\(n-1\)</span>个元素后，再来决定第<span
class="math inline">\(n\)</span>种元素该如何取。</p>
<p>在第<span
class="math inline">\(n\)</span>个元素的视角来看，如果有<span
class="math inline">\(a\)</span>、<span
class="math inline">\(b\)</span>和<span
class="math inline">\(c\)</span>三种取法，那么在取任何一种后，计算方法又回到上一段的最后。打个比方，如果确定的是<span
class="math inline">\(a\)</span>，那么下次我们可以取<span
class="math inline">\(b\)</span>或者<span
class="math inline">\(c\)</span>；如果这次确定的是<span
class="math inline">\(b\)</span>，那么下次同样我们可以取<span
class="math inline">\(a\)</span>或者<span
class="math inline">\(c\)</span>。</p>
<span id="more"></span>
<hr />
<p>由此引出一个问题，我们如何才能涉及到每一种取法呢？分治递归。</p>
<p>分治递归这种方法，一般当每一部分数据都包含同样的特征时就可以使用。比如遍历二叉树时，每一个节点都含有一个左孩子和一个右孩子，当遍历到这个节点的某个孩子时，又可以对它的孩子进行与它本身同样的操作，这样我们就可以对每个孩子进行递归。</p>
<hr />
<p>回到问题，当我们确定第<span
class="math inline">\(n\)</span>个节点时，此时就分出了<span
class="math inline">\(m\)</span>(方案数)种可能，而这m种方案各自又会分出具有同样特征的<span
class="math inline">\(m-1\)</span>种方案。</p>
<p>此时会抛出另一种问题，我们如何才能知道我们已经确定的元素是哪些，以便于我们在下次确定元素时不会和前面已确定的元素重复？</p>
<h2 id="括号生成">括号生成</h2>
<p>在括号生成问题中，由于每个括号包括一个左括弧和一个右括弧，因此我们可以用<code>left</code>来记录左括弧数，用<code>right</code>来记录右括弧数。如果我们迭代到某一步，发现可以使用的左括弧和右括弧的数量都已经没有了，那么我们就可以确定我们已经把所有的括弧对都加进字符串，此时直接返回字符串就可以了，否则我们可以选择下一次是添加左括弧还是添加右括弧，以此类推。</p>
<p><img src="../../../../images/kuohao.png" /></p>
<p>代码如下: <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">iter</span><span class="params">(vector&lt;string&gt;&amp; ans, <span class="type">int</span> left, <span class="type">int</span> right, string current)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!left &amp;&amp; !right) ans.<span class="built_in">push_back</span>(current);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left) <span class="built_in">iter</span>(ans, left<span class="number">-1</span>, right+<span class="number">1</span>, current+<span class="string">&quot;(&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (right) <span class="built_in">iter</span>(ans, left, right<span class="number">-1</span>, current+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        <span class="built_in">iter</span>(ans, n, <span class="number">0</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 在这段代码中，<span
class="math inline">\(iter\)</span>函数就是递归函数，每次递归到最末尾时我们用完了所有左右括弧，此时将最终字符串添加到向量类型<code>ans</code>中，如果仍然还有左括弧或者右括弧没有添加到字符串，那么我们可以添加左括弧或者右括弧，将这两种选择分而治之，每个人都分化出不同的括弧组合类型。</p>
<p>需要注意的是，由于我们只有先添加左括弧才能再添加右括弧，所以我们刚开始时右括弧数量为<span
class="math inline">\(0\)</span>，只有在某个左括弧添加进去后，我们才使右括弧数量加一。</p>
<h2 id="全排列">全排列</h2>
<p>在全排列问题中，我们不可以再用n个变量来记录我们的选择，因为此时需要全排列的元素我们无法确定到底有几个，但是根据题目下方的提示，我们发现最多只有<span
class="math inline">\(6\)</span>个元素进行全排列。 <img
src="../../../../images/%E6%8F%90%E7%A4%BA.png" /></p>
<p>而且因为每种元素只有已选中和未选中两种状态，所以可以用0和1来代表选中的状态，如果我们有<span
class="math inline">\(6\)</span>个元素，那么只需要一个取值<span
class="math inline">\(0\)</span>到<span
class="math inline">\(2^{6}-1\)</span>之间的整数，化为二进制后取值范围将在<span
class="math inline">\(b\)</span>x<span
class="math inline">\(000000\)</span>到<span
class="math inline">\(b\)</span>x<span
class="math inline">\(111111\)</span>之间，每一位是<span
class="math inline">\(0\)</span>时代表可以被选中，每一位是<span
class="math inline">\(1\)</span>时代表已经被选中。</p>
<p>分治方法也如同括号生成算法，当每找到一个<span
class="math inline">\(0\)</span>时就可以开启一个分支，从而可以取遍每种情况。算法如下:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constructor</span><span class="params">(<span class="type">int</span> tags, vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;ans, vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tags == <span class="built_in">pow</span>(<span class="number">2</span>, nums.<span class="built_in">size</span>())<span class="number">-1</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> tag = tags;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!(tag &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">nv</span><span class="params">(v)</span></span>;</span><br><span class="line">                nv.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">constructor</span>(tags+<span class="built_in">pow</span>(<span class="number">2</span>,i), ans, nv, nums);</span><br><span class="line">            &#125;</span><br><span class="line">            tag &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        <span class="built_in">constructor</span>(<span class="number">0</span>, ans, vector&lt;<span class="type">int</span>&gt;&#123;&#125;, nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中每个元素会产生<span
class="math inline">\(n!\)</span>种后缀，又存在<span
class="math inline">\(n\)</span>个元素，所以时间复杂度为<span
class="math inline">\(O(n\times{n!})\)</span>。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>分治递归</tag>
        <tag>回朔法</tag>
        <tag>刷题记录</tag>
      </tags>
  </entry>
  <entry>
    <title>《 THE ROMANOVS 》- 罗曼诺夫王朝</title>
    <url>/powehi.github.io/2022/08/22/romanovs/</url>
    <content><![CDATA[<p><strong>“我们历史上最大的罪人，是那些自己放弃权力的软蛋，尼古拉二世和米哈伊文·戈尔巴乔夫。他们竟允许权利被歇斯底里的狂人和疯子夺走。”</strong>
--- 弗拉基米尔·弗拉基米罗维奇·普京</p>
]]></content>
      <categories>
        <category>历史学</category>
      </categories>
      <tags>
        <tag>读书记录</tag>
        <tag>历史学</tag>
      </tags>
  </entry>
  <entry>
    <title>INTRODUCTION OF THE ROMANOVS</title>
    <url>/powehi.github.io/2022/09/09/romanoves1/</url>
    <content><![CDATA[<h2 id="开篇">开篇</h2>
<p>今天我分享的题目是，《罗曼诺夫王朝》--
俄国历史上最强盛的王朝，同时也是其历史上最后一个王朝。</p>
<p>当沙皇可不是一件轻松的事，俄国不是一个容易治理的国家，罗曼诺夫王朝有20位君主，一共统治了304年，从1613年一直到1917年革命爆发、沙皇体质被废除。他们的崛起从伊凡雷帝在位期间开始，到拉斯普京时期结束。</p>
<p>一些浪漫主义编年史学家喜欢暗示，暗示罗曼诺夫家族受到了诅咒，但其实罗曼诺夫皇朝是蒙古人之后最成功的帝国建设者。罗曼诺夫王朝不仅是皇朝与辉煌的象征，还成了专制暴政的代表，除了凯撒家族之外，没有一个皇朝在大众的想象和文化中占据这样突出的地位。“沙皇(tsar)”这个头衔源自凯撒(Caesar)绝非偶然，恰似俄语中的“皇帝”就是直接照搬拉丁语“imperator”一样。</p>
<span id="more"></span>
<p>Today The title which will be shared is "Romanov Dynasty" - the most
powerful dynasty in Russia's history, and also the last one in its
history.</p>
<p>Being a tsar was not an easy task, as Russia was not an easy country
to govern. The Romanov dynasty had 20 monarchs who ruled for a total of
304 years, from 1613 until the outbreak of the revolution and the
abolition of the tsarist physique in 1917. Their rise to power began
during the reign of Иван Грозный and ended under Rasputin.</p>
<p>Some Romantic chroniclers like to suggest that the Romanovs were
cursed, but in fact the Romanov dynasty was the most successful empire
builder since the Mongols. The Romanov dynasty was not only a symbol of
royalty and splendor, but also became a representative of despotic
tyranny, and with the exception of the Caesars, no imperial dynasty has
occupied such a prominent place in the popular imagination and culture.
It is no accident that the title "tsar" is derived from Caesar, just
like the Russian word "emperor" is a direct copy of the Latin word
"imperator".</p>
<h2 id="王朝的始末">王朝的始末</h2>
<p>为罗曼诺夫皇朝的故事拉开序幕又闭幕的，是两个十几岁的男孩，他们都天真、羸弱而疾病缠身，都在革命、战争与屠戮的年代成长，他们的父母都为他们争取最高的奖励--皇位，但没人能保护他们，因为他们的家族卷入了俄国权利的残酷游戏。</p>
<p>尽管他们有这么多相似之处，但他们最终走向截然不同的方向，其中一人的生活刚刚开始，而另一个人的末日已经降临。</p>
<p>1613年，米哈伊尔进入了神圣莫斯科城，所有教堂都响起了钟声；男人们续着长须、身穿长袍，头戴紫貂或黑色狐狸毛皮的帽子；女人们深居闺房，蒙着面纱被藏匿起来。</p>
<p>在隆重的游行队伍的簇拥下，男孩身穿拜占庭风格的金色长袍，穿过圣殿山，进入拥有五座穹顶的圣母升天大教堂，此后，克里姆林宫的三十三座大钟被敲响，廷臣们用鲜红色软垫捧着皇冠、圣球和权杖走出红色走廊，走下红色楼梯，穿过大教堂广场，走向圣母升天大教堂。伴随着僧人的吟唱，男孩在圣像前接受加冕。</p>
<p>直到1917年，那个起源于黑白条纹旗覆盖的土地，在几乎所有国家都传播开来的强大思想，随着王朝一艘战舰上的炮响为王朝敲响了丧钟，自此在世界上存在了304年的罗曼诺夫王朝，带着它的满身创伤和记忆，和霍亨索伦，哈布斯堡，奥斯曼等长久王朝的名字一起，消失在了历史的长河中。</p>
<p>Kicking off and closing the story of the Romanov dynasty are two
teenage boys, both naive, frail and disease-ridden, both growing up in a
time of revolution, war and slaughter, both with parents gave them the
highest prize of all - the throne - but with no one to protect them
because they have embroiled in the cruel game of Russian power.</p>
<p>Despite all their similarities, they end up heading in very different
directions, with life just beginning for one of them and the end already
upon the other.</p>
<p>In 1613, Mikhail entered the holy city of Moscow, and all the
churches rang their bells; the men keep their long beards , wear the
robes and with hats of sable or black fox fur; the women were deep in
their harems, veiled and hidden away.</p>
<p>Surrounded by a solemn procession, the boy, dressed in golden robes
in Byzantine style, crossed the Temple Mount and entered the Assumption
Cathedral which with five domes, then, with the thirty-three bells of
the Kremlin were rung, the courtiers carried crowns, sacred spheres and
scepters on bright red cushions out of the red corridor, down the red
staircase, across the Cathedral Square and towards the Assumption
Cathedral. With the chanting of the monks, the boy is crowned in front
of the icon.</p>
<p>Until 1917, a great and powerful thought, which derives in the land
which covered by black and white flag, and widespreaded in the world,
knock the death knell for the empire along with the gunfire in a
warship. Since, the Romanove Dynasty, which had existed in the world for
304 years, disappeared into history with its wounds and memories, along
with the names of Hohenzollern, Habsburg, Ottoman and other long-lasting
dynasties.</p>
<h2 id="标志性人物">标志性人物</h2>
<p>在这段历史中，我们最熟知的人物，或许是彼得大帝、叶卡捷琳娜女皇、拿破仑战争期间的沙皇亚历山大一世或者最后一位沙皇尼古拉二世。</p>
<p>彼得大帝是俄罗斯历史上最伟大的帝王。他继位后积极兴办工场，发展贸易，发展文化、教育和科研事业，同时改革军事，建立正规的陆海军，加强封建专制的中央集权制。继而发动了战争，夺得波罗的海出海口。可以说，近代俄国的政治、经济、文化、教育、科技等方面的发展史无不源于彼得大帝时代。彼得大帝将国家发展重心西移，邻近欧洲各国，便于接受欧洲的开化文明，并建立起圣彼得堡的领导势力，结束俄国由莫斯科政权统治以来的黑暗时期，带领俄国进入文明新时代。</p>
<p>尽管彼得大帝之后的继位女皇也叫做叶卡捷琳娜，但她只在位了不到两年时间，我们常说的可以被称为“大帝”的叶卡捷琳娜女皇指的是叶卡捷琳娜二世，是彼得大帝的外孙、彼得三世的妻子。</p>
<p>叶卡捷琳娜二世在位34年，是彼得大帝改革的忠实继承者，使俄国再次回到发展的轨道上来。叶卡捷琳娜二世统治时期，俄罗斯成为名副其实的欧洲最强大的国家，她不仅建立了横跨欧亚的俄罗斯帝国，而且她的风流韵事和男宠数不胜数，子女全是私生的，与中国的“武则天”极其相似，甚至有过之而无不及。</p>
<p>亚历山大一世是俄罗斯罗曼诺夫王朝第十四位沙皇，俄罗斯帝国的第十位皇帝，由于他在拿破仑战争中领导反法同盟击败法兰西帝国皇帝拿破仑一世，复兴欧洲王室，从而被欧洲各国贵族称为“欧洲的救世主”，加上其做为战后欧洲神圣同盟的领导者，故又被称为“神圣王”。他的统治前期主要在战争中渡过，后期则沉寂在和宫廷仕女游玩，以及对于神秘主义的研究上，开始渐渐不理政事，历史对他的评价往往呈现为两极分化的，他的行为不能被理解，因此又被称为”北方的斯芬克斯”和“两面神”。</p>
<p>Perhaps the figures who is the most familiar by us in this history
are Peter the Great, Catherine II, Tsar Alexander I during the
Napoleonic Wars or the last Tsar Nicholas II.</p>
<p>Peter the Great was the greatest emperor in the history of Russia.
After he succeeded to the throne, he actively built workshops, developed
trade, culture, education and scientific research, while reforming the
military, establishing a regular army, navy and strengthening the
centralized feudal autocracy. Subsequently, he waged war and occupied
the ports of the Baltic Sea. It can be said that the history of
political, economic, cultural, educational, scientific and technological
development of modern Russia has its roots in this time of Peter the
Great. Peter the Great shifted the focus of the country's development
westward, close to European countries, facilitating the acceptance of
enlightened European civilization and establishing the leadership of St.
Petersburg, which ended the dark period of Russia's rule by the Moscow
regime and led Russia into a new era of civilization.</p>
<p>Although the empress who succeeded Peter the Great was also called
Catherine, she reigned for less than two years, and the empress we often
refer to as "the Great" was Catherine II, the wife of the grandson of
Peter the Great.</p>
<p>Catherine II reigned for 34 years and was a faithful successor of
Peter the Great's reforms, which brought Russia back to the path of
development. During the reign of Catherine II, Russia became the most
powerful country in Europe, and she not only built the Russian Empire
across Europe and Asia, but also had countless affairs and male pets,
and all her children were born out of wedlock, similar to the Chinese
"Wu Zetian”.</p>
<p>Alexander I was the fourteenth tsar of the Romanov dynasty of Russia
and the tenth emperor of the Russian Empire. He was called the "Savior
of Europe" by the nobles of Europ, because he led the Anti-French
Alliance to defeat the French Emperor Napoleon I in the Napoleonic Wars
and revived the European royal family. He was also known as the "Holy
King" because he was the leader of the Holy Alliance in Europe after the
war. He spent the first part of his reign in wars, but the second part
of his reign in the study of mysticism and the pleasure of courtesans.
He is also known as the "Sphinx of the North" and the "God of Two
Faces".</p>
<p>“我们历史上最大的罪人，是那些自己放弃权力的软蛋，尼古拉二世和米哈伊文·戈尔巴乔夫。他们竟允许权利被歇斯底里的狂人和疯子夺走。”-普金曾经说过。</p>
<p>尼古拉二世缺乏一个做为改革者的资质，他懦弱无能、贪心又轻敌、紧握权利固步自封，他听信一个宗教骗子的谗言，对维特与斯托雷平心生猜疑乃至罢黜不用，使俄国的现代化计划荒废。最终1917年，在叶卡捷琳堡，伊帕基耶夫宅邸的地下室里，尼古拉二世连同新继位的年幼沙皇米哈伊尔被枪决。</p>
<p>As for Nicholas II</p>
<p>Pugin once said "The greatest sinners in our history are the
soft-heads who themselves gave up power, Nicholas II and Mikhail Ivan
Gorbachev. How dare they allow power to be taken away from them by
hysterical maniacs and madmen."</p>
<p>Nicholas II lacked the qualifications of a reformer, he was
incompetent, greedy and gullible, clinging to power, he listened to the
slander of a religious charlatan, was suspicious of Vetter and Stolypin
and even deposed them, finally led to the abandonment of Russia's
modernization program. In 1917, in the basement of the Ipakiyev
residence in Ekaterinburg, Nicholas II was executed by firing squad,
together with the new young Tsar Mikhail.</p>
]]></content>
      <categories>
        <category>历史学</category>
      </categories>
      <tags>
        <tag>读书记录</tag>
        <tag>历史学</tag>
      </tags>
  </entry>
  <entry>
    <title>一款好看的字体Zed Mono</title>
    <url>/powehi.github.io/2022/08/24/setzedfont/</url>
    <content><![CDATA[<h2 id="前言">前言</h2>
<p>听说最近Atom团队在Alpha测试一款新的编辑器<a
href="https://zed.dev">Zed</a>，使用Rust编写，由GPU来渲染用户界面，支持多人实时协同，目前已经支持包括C/C++、Python、GO、JavaScript、Markdown、Rust等11种语言，而他们的字体Zed-Mono在我看来具有一种更加舒适的设计，在他人分享的图片上看起来感觉比vscode的原生字体更加生动，因此我在这里分享一下我安装这款字体的经历。</p>
<p>这款字体目前可以在GitHub上找到，项目地址为https://github.com/zed-industries/zed-fonts.git。</p>
<span id="more"></span>
<h2 id="安装">安装</h2>
<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<thead>
<tr class="header">
<th
style="text-align: left;">老tip：我已经把build好的ttf文件分享到阿里云盘了，地址：https://www.aliyundrive.com/s/voRPDrZYBgj</th>
</tr>
</thead>
<tbody>
</tbody>
</table>
<p>我们可以先通过<code>git</code>将项目<code>clone</code>到本地：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> zedf &amp;&amp; <span class="built_in">cd</span> zedf   <span class="comment">#寻找一个存放项目文件的地方</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zed-industries/zed-fonts.git</span><br><span class="line"><span class="built_in">cd</span> zed-fonts</span><br></pre></td></tr></table></figure></p>
<p>根据<code>README.md</code>文件中的描述，需要我们运行<code>npm install</code>来安装节点模块，所以需要可以运行<code>npm</code>：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#在MacOS系统中，可以使用Homebrew包管理工具来安装npm</span></span><br><span class="line">brew search node    <span class="comment">#npm在Node v0.6.x版本后已经内建于Node系统</span></span><br><span class="line"><span class="comment">#在Ubuntu系统中，可以使用apt包管理工具来安装npm</span></span><br><span class="line">apt install nodejs npm</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装完成后，可以通过下面指令查看是否安装成功</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure> 运行结果： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">14:32@ ~ % npm -v</span><br><span class="line">8.15.0</span><br><span class="line">14:32@ ~ % </span><br></pre></td></tr></table></figure> 之后按照文档中的描述：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install <span class="comment">#运行结束后会生成一个node_modules文件</span></span><br><span class="line">npm run build -- contents::zed-mono</span><br><span class="line"><span class="comment">#结果会保存在zed-fonts/dist中</span></span><br><span class="line"><span class="comment">#14:35@ dist % ls</span></span><br><span class="line"><span class="comment">#zed-mono</span></span><br><span class="line"><span class="comment">#14:36@ dist % ls zed-mono </span></span><br><span class="line"><span class="comment">#ttf		ttf-unhinted	woff2		zed-mono.css</span></span><br></pre></td></tr></table></figure></p>
<p>有时候中间会报一些错误，需要结合实际情况进行修正，例如当我在刚开始安装时，报告错误：找不到<code>External dependency &lt;ttfautohint&gt;</code>。于是我在网上找到<code>ttfautohint</code>文件并下载到本地，并在<code>terminal</code>中运行：
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$&#123;PATH&#125;</span>:/ttfautohint的绝对路径</span><br></pre></td></tr></table></figure> 然后重新运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm run build -- contents::zed-mono</span><br></pre></td></tr></table></figure>
期间可能CPU和ARM的占用会比较高，耗时会比较长，这并不是卡住，只需要多等待一些时间就可以了。</p>
<h2 id="设置">设置</h2>
<p>之后进入<code>/dist/zed-mono/ttf</code>，这里会包含很多<code>ttf</code>字体文件，将它们全选后打开：</p>
<p><img src="../../../../images/zedttf.png" /></p>
<p>选择安装字体，系统字体册中就可以找到<code>Zed Mono</code>字体：</p>
<p><img src="../../../../images/zedmono.png" /></p>
<p>之后打开Vs
Code，进入设置搜索<code>font</code>，在<code>Font Family</code>处修改为<code>Zed Mono</code>后就会自动加载新字体。</p>
<h2 id="效果">效果</h2>
<p>实际效果如下：</p>
<p><img src="../../../../images/zedshow.png" /></p>
]]></content>
      <categories>
        <category>工具美化</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>统计学习概论</title>
    <url>/powehi.github.io/2022/08/21/statistic/</url>
    <content><![CDATA[<h2 id="统计学习的特点">统计学习的特点：</h2>
<ol type="1">
<li>统计学习以计算机及网络为平台，建立在计算机及网络上</li>
<li>统计学习以数据为研究对象，是数据驱动的学科</li>
<li>统计学习的目的是对数据进行预测与分析</li>
<li>统计学习以方法为中心，构建模型并对模型进行预测与分析</li>
<li>统计学习是概率论、统计学、信息论、计算理论、最优化理论及计算机科学等多个领域的交叉学科</li>
</ol>
<span id="more"></span>
<table>
<tbody>
<tr class="odd">
<td>赫尔伯特<span class="math inline">\(·\)</span>西蒙 (Herbert A.Simon)
曾对学习给出以下定义：“如果一个系统能够通过执行某个过程改进它的性能，这就是学习。”</td>
</tr>
</tbody>
</table>
<h2 id="统计学习的对象数据">统计学习的对象：数据</h2>
<p>它从数据出发，提取数据的特征，抽象出数据的模型，发现数据中的知识，
回到对数据的分析和预测中去。</p>
<p>统计学习中对数据的基本假设：同类数据具有一定的统计规律性，这是统计学习的前提。</p>
<h2
id="统计学习的目的用于对数据的预测和分析特别是对未知数据的预测与分析">统计学习的目的：用于对数据的预测和分析，特别是对未知数据的预测与分析。</h2>
<h3 id="考虑两点">考虑两点</h3>
<ol type="1">
<li>学习什么样的模型</li>
<li>如何学习模型</li>
</ol>
<h2
id="统计学习方法从给定的有限的用于学习的训练数据集和出发假设数据是独立同分布产生的并且要学习的模型属于某个函数的集合假设空间">★
统计学习方法：从给定的、有限的、用于学习的训练数据集和出发，假设数据是独立同分布产生的；并且要学习的模型属于某个函数的集合(假设空间)</h2>
<h3 id="一包括三点三要素">一、包括三点，三要素</h3>
<ol type="1">
<li>模型的假设空间（模型model）</li>
<li>模型选择的准则（策略strategy）</li>
<li>模型学习的算法（算法algorithm）</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td>如果最优化问题又显式的解析解，这个最优化问题就比较简单。但通常解析解不存在，就需要用数值计算的方法求解。如何保证找到全局最优解，并使求解的过程非常高效，就成为一个重要问题。</td>
</tr>
</tbody>
</table>
<h3 id="二损失函数与风险函数">二、损失函数与风险函数**</h3>
<ol type="1">
<li><p><span class="math inline">\(0\)</span>-<span
class="math inline">\(1\)</span>损失函数（<span
class="math inline">\(0\)</span>-<span class="math inline">\(1\)</span>
loss function）</p>
<p><span class="math display">\[\displaystyle{L(Y,f(X))=\begin{cases}1
&amp; Y\neq f(X) \\ 0 &amp;  Y= f(X)\end{cases}}\]</span></p></li>
<li><p>平方损失函数（quadratic loss function）</p>
<p><span
class="math display">\[\displaystyle{L(Y,f(X))=(Y-f(X))^2}\]</span></p></li>
<li><p>绝对损失函数（absolute loss function）</p>
<p><span
class="math display">\[\displaystyle{L(Y,f(X))=|Y-f(X)|}\]</span></p></li>
<li><p>对数损失函数（logarithmic loss function）</p>
<p><span class="math display">\[\displaystyle{L(Y,f(X))=-\log
P(Y|X)}\]</span></p></li>
</ol>
<ul>
<li><p>损失函数值越小，模型就越好，下面是损失函数的期望值：</p>
<p><span
class="math display">\[\displaystyle{R_{exp}(f)=E_P[L(Y,f(X))]=\int_{\Chi
* \Upsilon}L(y,f(x))P(x,y)dxdy}\]</span></p></li>
<li><p>理论上模型<span
class="math inline">\(f(X)\)</span>关于联合分布<span
class="math inline">\(P(X,Y)\)</span>的平均意义下的损失，成为<code>风险函数</code>或<code>期望损失</code>，学习目标就是选择期望风险最小的模型</p></li>
</ul>
<h3
id="三经验风险最小化与结构风险最小化">三、经验风险最小化与结构风险最小化</h3>
<p>经验风险是模型关于训练样本集的平均损失，根据大数定理，样本容量<span
class="math inline">\(N\)</span>趋于无穷大时经验风险<span
class="math inline">\(R_{emp}(f)\)</span>趋于期望风险<span
class="math inline">\(R_{exp}(f)\)</span>，但现实是训练样本有限，所以经验风险估计期望常常并不理想，要对经验风险进行一定矫正。</p>
<p><strong>这就关系到监督学习的两个基本策略：经验风险最小化和结构风险最小化。</strong></p>
<ol type="1">
<li><p>经验风险最小化</p>
<p>当模型是条件概率分布、损失函数是对数损失函数、经验风险最小化就等价于极大似然估计。</p>
<p><span
class="math display">\[\displaystyle{R_{emp}(f)=\cfrac{1}{N}\quad\sum_{i=1}^{N}L(y_i,f(x_i))}\]</span></p></li>
<li><p>结构风险最小化</p>
<p>结构分概念最小化等价于正则化（regularizer）。</p>
<p>结构风险在经验风险上加上表示模型复杂度的正则化（regularizer）或罚项（penalty
term）。</p>
<p><span
class="math display">\[\displaystyle{R_{emp}(f)=\cfrac{1}{N}\quad\sum_{i=1}^{N}L(y_i,f(x_i))
+ \lambda J(f)}\]</span></p>
<p>其中<span class="math inline">\(J(f)\)</span>为模型复杂度，模型<span
class="math inline">\(f\)</span>越复杂，复杂度<span
class="math inline">\(J(f)\)</span>就越大；<span
class="math inline">\(\lambda
\geqslant0\)</span>是系数，用以权衡经验风险和模型复杂度。</p></li>
</ol>
<h2 id="统计学习的研究">统计学习的研究</h2>
<ol type="1">
<li>统计学习方法的研究旨在开发新的<strong>学习方法</strong></li>
<li>统计学习理论的研究在于探求统计学习方法的<strong>有效性与效率</strong>，以及统计学习的<strong>基本理论问题</strong></li>
<li>统计学习应用的研究主要考虑将统计学习方法<strong>应用到实际问题中去</strong>，解决实际问题</li>
</ol>
<h2 id="模型评估与模型选择">模型评估与模型选择</h2>
<p>当损失函数给定时，基于损失函数的训练误差和模型的测试误差就成为学习方法的评估标准。</p>
<blockquote>
<p>过拟合问题：如果一味提高测试数据的预测能力，就可能导致过拟合问题。具体体现在学习是选择的模型参数过多，对已知的测试数据预测效果很好，但对于未知数据预测结果很差。</p>
</blockquote>
<p><img src="../../../../images/IMG_0584.jpg" /></p>
<hr />
<p>如果在假设空间中存在“真”模型，那么所选模型要与真模型参数个数相同，参数向量与真模型的参数向量相近。</p>
<blockquote>
<p>对于测试误差，会随着模型复杂度先减小，达到最小之后又增大</p>
</blockquote>
<p><img src="../../../../images/PNG图像.png" /></p>
<hr />
<h2 id="正则化验证与交叉验证">正则化验证与交叉验证</h2>
<p><code>两种用于选择模型的方法</code></p>
<ul>
<li><p>其中<strong>正则化验证</strong>是结构风险最小化策略的实现，正则化符合奥卡姆剃须刀原理：在所有可能选择的模型中，能够很好解释已知数据并且十分简单的才是好模型。</p></li>
<li><p>另一种常用的是<strong>交叉验证</strong>，对于给定的样本，将其随机切分成三部分，分别是训练集（训练模型）、验证集（选择模型）、测试集（评估模型）。基本思想是重复使用数据，可以应对实际问题中数据不足的问题。</p></li>
</ul>
<h3 id="一交叉验证的三种类型">一、交叉验证的三种类型</h3>
<ol type="1">
<li><p>简单交叉验证</p>
<p>例如在<span
class="math inline">\(MNIST\)</span>分类问题中将样本随机分成两部分、测试集（<span
class="math inline">\(30\%\)</span>）与训练集（<span
class="math inline">\(70\%\)</span>）。</p></li>
<li><p><span class="math inline">\(S\)</span>折交叉验证</p>
<p>将数据切分成<span
class="math inline">\(S\)</span>个互不相交、大小相同的子集，利用<span
class="math inline">\(S-1\)</span>个子集数据进行训练，用余下的数据测试模型；将这一过程进行<span
class="math inline">\(S\)</span>次重复选择，最后选出评价误差最小的模型。</p></li>
<li><p>留一交叉验证</p>
<p>是<span class="math inline">\(S\)</span>折交叉验证的特殊情形（<span
class="math inline">\(S=N\)</span>），往往在数据缺乏的情况下使用。</p></li>
</ol>
<h2 id="泛化误差">泛化误差</h2>
<blockquote>
<p>泛化是指模型对未知数据的预测能力，泛化误差反映了学习方法的泛化能力。事实上，泛化误差就是所学到模型的期望风险。<span
class="math inline">\(\displaystyle{R_{exp}(\hat{f})=E_P[L(Y,\hat{f}(X))]=\int_{\Chi*\Upsilon}L(y,\hat{f}(x))P(x,y)dxdy}\)</span></p>
</blockquote>
<p><code>泛化误差上界，假设空间越大，模型越难学习，泛化误差上界越大</code></p>
<p>对于<span class="math inline">\(f_N\)</span>的泛化能力，<span
class="math inline">\(R(f_N)=E[L(Y,f_N(X))]\)</span></p>
<p><img src="../../../../images/PNG图像_2.png" /></p>
<hr />
<ul>
<li><span class="math inline">\(Hoefffding\)</span>不等式</li>
</ul>
<p><img src="../../../../images/PNG图像_3.png" /></p>
<p><img src="../../../../images/PNG图像_4.png" /></p>
<hr />
<h2 id="生成模型与判别模型">生成模型与判别模型</h2>
<p><em>监督学习方法又可以分为生成方法（generative
approach）与判别方法（discriminative
approach），所学到的模型分别为生成模型（generative
model）与判别模型（discriminative model）。</em></p>
<ol type="1">
<li>生成方法由数据学习联合概率密度<span
class="math inline">\(P(X,Y)\)</span>，然后求出条件概率密度<span
class="math inline">\(P(Y|X)\)</span>，即生成模型<span
class="math inline">\(\displaystyle{P(Y|X)=\cfrac{P(X,Y)}{P(X)}}\)</span>。</li>
</ol>
<blockquote>
<p><strong>典型生成模型</strong>：朴素贝叶斯法，隐马尔可夫模型</p>
<p><strong>特点：可以还原出联合概率密度，收敛速度快，当存在隐变量时仍然可以使用</strong></p>
</blockquote>
<ol start="2" type="1">
<li>判别方法直接学习决策模型<span
class="math inline">\(f(X)\)</span>或者条件概率密度<span
class="math inline">\(P(Y|X)\)</span>，作为预测模型。</li>
</ol>
<blockquote>
<p><strong>典型判别模型</strong>：<span
class="math inline">\(k\)</span>近邻法、感知机、决策树、逻辑斯蒂回归模型、最大熵模型、支持向量机、提升方法、条件随机场等</p>
<p><strong>特点：准确率更高，方便对数据进行各种程度上的抽象，定义特征并使用特征，简化学习问题</strong></p>
</blockquote>
<h2 id="监督学习应用">监督学习应用</h2>
<ol type="1">
<li><p>分类问题</p></li>
<li><p>标注问题（隐马尔可夫模型，条件随机场）</p></li>
<li><p>回归问题</p>
<p>用于预测输入变量和输出变量之间的关系，当输入发生变化时，输出值随之发生变化。
回归模型正是输入变量到输出变量之间的映射函数，等价于函数拟合。</p></li>
</ol>
<ul>
<li>根据输入变量个数分为一元回归和多元回归；按照所拟合函数类型分为线性回归和非线性回归。</li>
<li>最常用的是平方损失函数，可以用最小二乘法求解。</li>
</ul>
]]></content>
      <categories>
        <category>数学</category>
        <category>人工智能</category>
      </categories>
      <tags>
        <tag>读书记录</tag>
        <tag>统计学习</tag>
      </tags>
  </entry>
</search>
